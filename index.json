[{"content":" Why Programs Fail: A Guide to Systematic Debugging (Andreas Zeller)\nü™≤ How do you debug a software issue? For me, it has always been a combination of staring at the program code very intensely, collecting evidence from past runs, intuition, and a lot of trial and error: keep changing things until the problem disappears.\nüî¨ Can we evolve past these \u0026ldquo;random\u0026rdquo;, unguided approaches, and debug a program using the scientific method? After all we\u0026rsquo;re software engineers, and the distinctive quality of engineers is the use of scientific principles to design and build systems.\nüì¶ Contents The book first presents a sound theoretical and practical framework to identify, report, and reproduce failures. It then explains how to systematically isolate the \u0026ldquo;infection\u0026rdquo; from a failure report by elaborating hypotheses and building controlled experiments (not random trial \u0026amp; error!) to prove or disprove them. Finally, it shows how to pinpoint and correct the software defect that is causing the issue.\nThe book introduces a simple and practical search algorithm to pinpoint the cause of failures based on binary search (delta debugging), showing a practical application where it tracks down a bug in a complex software project such as GCC. It shows some innovative research applications of static and dynamic analysis techniques that aren\u0026rsquo;t yet available in commercial IDEs.\nThe most valuable teaching from the book\u0026mdash;for me\u0026mdash;has been Chapter 6, which explains:\nThat there are 4 ways to reason about a program: deduction, observation, induction, and experimentation. How to elaborate hypotheses about the cause of a failure: every hypothesis must include all the earlier confirmed hypotheses, and exclude all the earlier disproved hypotheses. How to build a controlled experiment to prove or disprove the hypothesis. This is the only way to prove causality by its very definition, which is counterfactual (A causes B if, without A, B does not happen). This is the scientific method, applied to software engineering. The author claims that \u0026ldquo;among all scientific disciplines debugging is the one that can best claim to deal with actual causality\u0026rdquo;. I couldn\u0026rsquo;t agree more.\nThe book wraps up with a chapter about how to fix bugs:\none at a time with regression tests adding assertions where needed checking every fix to retrospectively validate causality The last chapter (\u0026ldquo;Learning from Mistakes\u0026rdquo;) explains how to set up software engineering processes to prevent and catch bugs early (ideally, at the specification phase), and how to identify the \u0026ldquo;riskiest\u0026rdquo; software modules. Very relevant for tech leads and engineering managers.\nüíØ My impression I found the book rigorous and insightful. It is a much-needed wake-up call for software engineers to work more scientifically, and to avoid considering debugging an \u0026ldquo;art\u0026rdquo; or an exoteric discipline.\nIt\u0026rsquo;s shocking how little of the research state-of-the-art is shipped in the commercially available software development tools. The most advanced debugging tool most people (including me) have ever used in their profession is the \u0026ldquo;classic\u0026rdquo; debugger with the same features from 15 years ago. There\u0026rsquo;s so much more we could do! (In particular, I\u0026rsquo;d love to use an omniscient debugger\u0026hellip;)\nI found only two minor shortcomings:\nThe book is very \u0026ldquo;academic\u0026rdquo;: it presents the state of the art of the \u0026ldquo;systematic debugging\u0026rdquo; research area, and does not investigate the industry best practices. From my (limited) experience, however, the commercially available debugging tools are well behind what has proven possible by the research. Most of the debugging techniques that are listed assume that one is always able to reproduce a failure deterministically, and that doing so is inexpensive. In my experience with cloud-based and distributed systems, this is not always true: we often deal with intermittent failures that are hard to even reproduce. In these cases, one is limited to applying the advice about assertions and static analysis, as dynamic analysis becomes impossible. Overall, the book is full of practical and actionable advice, and I found it a great read. I\u0026rsquo;d recommend it to all software developers with a computer science background.\n","permalink":"https://blog.pietrodn.com/posts/why-programs-fail/","summary":"Why Programs Fail: A Guide to Systematic Debugging (Andreas Zeller)\nü™≤ How do you debug a software issue? For me, it has always been a combination of staring at the program code very intensely, collecting evidence from past runs, intuition, and a lot of trial and error: keep changing things until the problem disappears.\nüî¨ Can we evolve past these \u0026ldquo;random\u0026rdquo;, unguided approaches, and debug a program using the scientific method?","title":"üìñ Book review: \"Why Programs Fail\" by Andreas Zeller"},{"content":"On June 6th, 2022, I held a seminar at Universit√† degli Studi di Milano about Ethereum: virtual currency, state machines, and programmable money.\nThe presentation is about Ethereum from the point of view of a computer scientist. It discusses Ethereum\u0026rsquo;s global state, the consensus mechanism, smart contracts, ERC20, and more.\nThe slides are publicly available (Google Sheets; PDF).\n","permalink":"https://blog.pietrodn.com/posts/ethereum-compsci-presentation/","summary":"On June 6th, 2022, I held a seminar at Universit√† degli Studi di Milano about Ethereum: virtual currency, state machines, and programmable money.\nThe presentation is about Ethereum from the point of view of a computer scientist. It discusses Ethereum\u0026rsquo;s global state, the consensus mechanism, smart contracts, ERC20, and more.\nThe slides are publicly available (Google Sheets; PDF).","title":"Ethereum for computer scientists"},{"content":"Hi folks üëãüèºüëã, welcome to my blog!\nI\u0026rsquo;m not going to publish with any particular frequency. This site is meant more as a repository of the things I deem worthy to put in writing.\n","permalink":"https://blog.pietrodn.com/posts/welcome/","summary":"Hi folks üëãüèºüëã, welcome to my blog!\nI\u0026rsquo;m not going to publish with any particular frequency. This site is meant more as a repository of the things I deem worthy to put in writing.","title":"Welcome!"},{"content":" Hi, I\u0026rsquo;m Pietro.\nI\u0026rsquo;m a software engineer from Milan, Italy.\nMy passions:\nüìö Reading (GoodReads profile) üíª Programming (GitHub profile) üè¶ Personal finance, cryptocurrency investing I currently work for Bending Spoons.\nOpen knowledge I recognize the immense contribution that open, free knowledge has given to the world.\nIn the past I\u0026rsquo;ve been an active Wikipedia contributor under the username of Pietrodn; from 2006 to 2009, I\u0026rsquo;ve been an administrator of the Italian Wikipedia.\nI developed three tools to help Wikimedians work more efficiently on their projects:\nSection Links analyzes all the links incoming from or arriving to a specific page and shows those pointing to non-existing sections. Intersect Contribs intersects the contribution history of two users on a Wikimedia project to find which pages have been edited by both of them. It\u0026rsquo;s useful to discover sockpuppets, double votes and false accounts. itwikinews-rss is a tool that automatically generates a RSS feed for the Italian version of Wikinews, Wikinotizie. I\u0026rsquo;m a member of Wikimedia Italia, the Italian branch of the Wikimedia Foundation. Please consider giving your 5x1000, or donating, to Wikimedia Italia.\nOpen source Here\u0026rsquo;s a list of free and open source projects I have contributed to:\nCCXT DroneKit-Python Work Bending Spoons (2019 ‚Äì present) Software Engineering Lead of the Algorithmic Trading team.\nDeveloping data acquisition, data processing, and live trading systems on cryptocurrencies.\nP.S.: we are a very desirable place to work for. And we\u0026rsquo;re hiring!\nFLYToons (2017 ‚Äî 2019) Designing, implementing and deploying the distributed software components enabling the control of autonomous drone fleets. In particular, I worked on:\nremote drone control using the MAVLink protocol (Python); 3D modeling of drone trajectories and lights (Blender, Python); automated configuration management of the drone fleet (Ansible); system administration on embedded Linux platform (Raspbian and Armbian OS); test flights and data analysis; tuning, configuring and fixing the open-source PX4 flight firmware; setup and maintenance of the VCS and CI infrastructure. Education Politecnico di Milano 2015-2017: M.Sc. in Computer Science and Engineering (110/110, cum laude) Thesis: Supervised learning approaches to assist the static analysis of executable files 2012-2015: B.Sc. in Computer Science and Engineering (110/110, cum laude) High School 2007-2012: Liceo Scientifico \u0026ldquo;Albert Einstein\u0026rdquo; di Milano (100/100) Publications DIMVA 2018: ELISA: ELiciting ISA of Raw Binaries for Fine-Grained Code and Data Separation (full text) ","permalink":"https://blog.pietrodn.com/about/","summary":"Hi, I\u0026rsquo;m Pietro.\nI\u0026rsquo;m a software engineer from Milan, Italy.\nMy passions:\nüìö Reading (GoodReads profile) üíª Programming (GitHub profile) üè¶ Personal finance, cryptocurrency investing I currently work for Bending Spoons.\nOpen knowledge I recognize the immense contribution that open, free knowledge has given to the world.\nIn the past I\u0026rsquo;ve been an active Wikipedia contributor under the username of Pietrodn; from 2006 to 2009, I\u0026rsquo;ve been an administrator of the Italian Wikipedia.","title":"About me"}]